<?php

use Symfony\Component\Finder\Finder;
use Symfony\Component\Filesystem\Filesystem;

require_once(__DIR__ . '/../vendor/autoload.php');

const NS = 'Sulu\Component\PhpcrDecorator\\';

$phpcrDir = __DIR__ . '/../vendor/phpcr/phpcr/src';

global $irregularMap;
$irregularMap = array(
    'And' => 'AndConstraint',
    'ChildNode' => 'ChildNodeConstraint',
    'FullTextSearch' => 'FullTextSearchConstraint',
    'Not' => 'NotConstraint',
    'Or' => 'OrConstraint',
);

$excludePatterns = array('{.*Test.*}');

$finder = new Finder();
$finder->name('*.php')->files()->in($phpcrDir);

foreach ($finder as $file) {
    $res = fopen($file, 'r');
    $class = $namespace = null;

    while ($line = fgets($res)) {
        if (preg_match('{^namespace ([^\s]+?);$}', $line, $matches)) {
            $namespace = $matches[1];
        }

        if (preg_match('{^interface ([^\s]+)}', $line, $matches)) {
            $class = $matches[1];
        }

        if ($class && $namespace) {
            break;
        }
    }

    if (!$class || !$namespace) {
        continue;
    }

    $fqn = $namespace . "\\" . $class;

    $reflection = new \ReflectionClass($fqn);

    generate_wrapped('', 'lib', 'generate_class', $reflection);
    generate_wrapped('Test', 'tests', 'generate_test', $reflection);
    fclose($res);
}

function writeln($mess)
{
    echo $mess . "\n";
}

function generate_wrapped($suffix, $dir, $fname, \ReflectionClass $refl)
{
    $fs = new Filesystem();
    $decoratedNameFqcn = preg_replace('{(.*)Interface}', '\1', $refl->name) . $suffix;
    $decoratedPath = str_replace('vendor/phpcr/phpcr/src', $dir, $refl->getFileName());
    $decoratedPath = str_replace('Interface', $suffix, $decoratedPath);

    $className = normalizeClassName(strstr(basename($decoratedPath), '.', true));
    $decoratedPath = dirname($decoratedPath) . '/' . $className . '.php';

    $classCode = $fname($refl, $decoratedNameFqcn);

    if (!file_exists(dirname($decoratedPath))) {
        $fs->mkdir(dirname($decoratedPath));
    }

    if (file_exists($decoratedPath)) {
        $fs->remove($decoratedPath);
    }

    file_put_contents($decoratedPath, $classCode);
}

function getClassNamespace($fqcn)
{
    global $irregularMap;

    preg_match('{^(.*?)\\\([^\\\]+)$}', $fqcn, $matches);

    if (!$matches) {
        throw new \Exception('Could not determine class and namespace');
    }
    $className = normalizeClassName($matches[2]);
    $namespace = $matches[1];


    return array($className, $namespace);
}

function normalizeClassName($name)
{
    global $irregularMap;
    if (isset($irregularMap[$name])) {
        return $irregularMap[$name];
    }

    return $name;
}

function generate_class(\ReflectionClass $refl, $fqcn)
{
    list($className, $namespace) = getClassNamespace($fqcn);

    if (!file_exists($refl->getFileName())) {
        continue;
    }

    $body = array();

    foreach ($refl->getMethods() as $method) {
        $params = $method->getParameters();

        $args = array();
        $fullArgs = array();


        foreach ($params as $param) {
            //$refl = new \ReflectionClass($param);
            //var_dump($refl->getMethods());die();;
            $args[] = '$' . $param->name;
            $fullArg = array();
            if ($param->getClass()) {
                $fullArg[] = '\\' . $param->getClass()->name;
            }

            if ($param->isArray()) {
                $fullArg[] = 'array ';
            }
            $fullArg[] = '$' . $param->name;
            $paramRef = new ReflectionClass($param);

            if ($param->isDefaultValueAvailable()) {
                $fullArg[] = ' = ' . var_export($param->getDefaultValue(), true);
            }

            $fullArgs[] = implode($fullArg);
        }

        $args = implode(', ', $args);

        $body[] = '    /**';
        $body[] = '     * {@inheritDoc}';
        $body[] = '     */';
        $body[] = sprintf('    public function %s(%s)', $method->name, implode(', ', $fullArgs));
        $body[] = '    {';
        $body[] = sprintf('        return $this->decoratorFactory->decorate(__METHOD__, $this->component->%s(%s));',
            $method->name,
            $args
        );
        $body[] = '    }';
        $body[] = '';
    }


    $interfaces = array();
    $extra = array();
    if ($refl->isSubclassOf('\Traversable') && !$refl->isSubclassOf('Iterator')) {
        $interfaces[] = '\\IteratorAggregate';
        $extra[] = '    public function getIterator()';
        $extra[] = '    {';
        $extra[] = '        throw new \Exception("Iterators not supported on decorated objects (yet)");';
        $extra[] = '    }';
        $extra[] = '';
    }

    $interfaces[] = '\\' . $refl->name;

    $t = array();
    $t[] = '<?php';
    $t[] = '';
    $t[] = '// autogenerated: ' . date('r');
    $t[] = '';
    $t[] = 'namespace ' . NS . $namespace . ';';
    $t[] = '';
    $t[] = '';
    $t[] = 'class ' . $className . ' implements ' . implode(', ', $interfaces);
    $t[] = '{';
    $t[] = '    protected $component;';
    $t[] = '    protected $decoratorFactory;';
    $t[] = '';

    $t[] = '    public function __construct(';
    $t[] = '        \\' . $refl->name . ' $component,';
    $t[] = '        \Sulu\Component\PhpcrDecorator\DecoratorFactoryInterface $decoratorFactory';
    $t[] = '    )';
    $t[] = '    {';
    $t[] = '        $this->component = $component;';
    $t[] = '        $this->decoratorFactory = $decoratorFactory;';
    $t[] = '    }';
    $t[] = '';

    foreach ($body as $line) {
        $t[] = $line;
    }

    foreach ($extra as $line) {
        $t[] = $line;
    }

    $t[] = '}';

    $template = implode("\n", $t);

    return $template;
}

function generate_test(\ReflectionClass $refl, $fqcn)
{
    $decoratedFqcn = str_replace('Tests', '', $fqcn);
    $decoratedFqcn = str_replace('Test', '', $fqcn);
    $testName = NS . 'Tests\\' . $fqcn;
    list($className, $namespace) = getClassNamespace($fqcn);
    list($decoratedClassName, $decoratedNamespace) = getClassNamespace($decoratedFqcn);

    $t = array();
    $t[] = '<?php';
    $t[] = '';
    $t[] = 'class ' . $className . ' extends \PHPUnit_Framework_TestCase';
    $t[] = '{';
    $t[] = '    public function setUp()';
    $t[] = '    {';
    $t[] = '        $this->component = $this->getMockBuilder("' . $refl->name . '")->disableOriginalConstructor()->getMock();';
    $t[] = '        $this->decoratorFactory = new \Sulu\Component\PhpcrDecorator\Factory\PassthruDecoratorFactory();';
    $t[] = '    }';
    $t[] = '';
    $t[] = '    public function testInstantiation()';
    $t[] = '    {';
    $t[] = '        new ' . NS . $decoratedNamespace . '\\' . $decoratedClassName . '($this->component, $this->decoratorFactory);';
    $t[] = '    }';
    $t[] = '}';

    return implode("\n", $t);
}
