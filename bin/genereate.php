<?php

use Symfony\Component\Finder\Finder;
use Symfony\Component\Filesystem\Filesystem;

require_once(__DIR__ . '/../vendor/autoload.php');

const NS = 'Sulu\Component\PhpcrDecorator\\';

$phpcrDir = __DIR__ . '/../vendor/phpcr/phpcr/src';

global $irregularMap;
$irregularMap = array(
    'And' => 'AndConstraint',
    'ChildNode' => 'ChildNodeConstraint',
    'FullTextSearch' => 'FullTextSearchConstraint',
    'Not' => 'NotConstraint',
    'Or' => 'OrConstraint',
);

$excludePatterns = array('{.*Test.*}');

$finder = new Finder();
$finder->name('*.php')->files()->in($phpcrDir);

foreach ($finder as $file) {
    $res = fopen($file, 'r');
    $class = $namespace = null;

    while ($line = fgets($res)) {
        if (preg_match('{^namespace ([^\s]+?);$}', $line, $matches)) {
            $namespace = $matches[1];
        }

        if (preg_match('{^interface ([^\s]+)}', $line, $matches)) {
            $class = $matches[1];
        }

        if ($class && $namespace) {
            break;
        }
    }

    if (!$class || !$namespace) {
        continue;
    }

    $fqn = $namespace . "\\" . $class;

    $reflection = new \ReflectionClass($fqn);

    generate_wrapped('', 'lib', 'generate_class', $reflection);
    generate_wrapped('Test', 'tests', 'generate_test', $reflection);
    fclose($res);
}

function writeln($mess)
{
    echo $mess . "\n";
}

function generate_wrapped($suffix, $dir, $fname, \ReflectionClass $refl)
{
    $fs = new Filesystem();
    $decoratedNameFqcn = preg_replace('{(.*)Interface}', '\1', $refl->name) . $suffix;
    $decoratedPath = str_replace('vendor/phpcr/phpcr/src', $dir, $refl->getFileName());
    $decoratedPath = str_replace('Interface', $suffix, $decoratedPath);

    $className = normalizeClassName(strstr(basename($decoratedPath), '.', true));
    $decoratedPath = dirname($decoratedPath) . '/' . $className . '.php';

    $classCode = $fname($refl, $decoratedNameFqcn);

    if (!file_exists(dirname($decoratedPath))) {
        $fs->mkdir(dirname($decoratedPath));
    }

    if (file_exists($decoratedPath)) {
        $fs->remove($decoratedPath);
    }

    file_put_contents($decoratedPath, $classCode);
}

function getClassNamespace($fqcn)
{
    global $irregularMap;

    preg_match('{^(.*?)\\\([^\\\]+)$}', $fqcn, $matches);

    if (!$matches) {
        throw new \Exception('Could not determine class and namespace');
    }
    $className = normalizeClassName($matches[2]);
    $namespace = $matches[1];


    return array($className, $namespace);
}

function normalizeClassName($name)
{
    global $irregularMap;
    if (isset($irregularMap[$name])) {
        return $irregularMap[$name];
    }

    return $name;
}

function generate_class(\ReflectionClass $refl, $fqcn)
{
    list($className, $namespace) = getClassNamespace($fqcn);

    if (!file_exists($refl->getFileName())) {
        continue;
    }

    $fileContents = file_get_contents($refl->getFileName());
    $lines = explode("\n", $fileContents);

    $useStatements = array();

    foreach ($lines as $line) {
        if (preg_match('{^use (.*)}', $line, $matches)) {
            $useStatements[] = $matches[1];
        }

        if (preg_match('{^class}', $line)) {
            break;
        }
    }

    unset($lines);

    $b = array();
    $usedClasses = array();

    foreach ($refl->getMethods() as $method) {
        $lineNo = $method->getStartLine();

        if (!file_exists($method->getFileName())) {
            continue;
        }


        $fileContents = file_get_contents($method->getFileName());
        $lines = explode("\n", $fileContents);
        $methodLine = str_replace(';', '', $lines[$lineNo -1]);

        unset($lines, $fileContents);

        $params = $method->getParameters();

        $args = array();
        foreach ($params as $param) {
            $args[] = '$' . $param->name;
            if ($param->getClass()) {
                $usedClasses[$param->getClass()->name] = $param->getClass()->name;
            }
        }
        $args = implode(' ', $args);

        $b[] = '    /**';
        $b[] = '     * {@inheritDoc}';
        $b[] = '     */';
        $b[] = $methodLine;
        $b[] = '    {';
        $b[] = sprintf('        return $this->getDecorator()->decorate(__METHOD__, $this->__component()->%s(%s));',
            $method->name,
            $args
        );
        $b[] = '    }';
        $b[] = '';
    }

    $t = array();
    $t[] = '<?php';
    $t[] = '';
    $t[] = '// autogenerated: ' . date('r');

    $t[] = '';
    $t[] = 'namespace ' . NS . $namespace . ';';
    $t[] = '';

    foreach ($usedClasses as $usedClass) {
        $t[] = 'use ' . $usedClass . ';';
    }

    $t[] = '';

    $t[] = 'class ' . $className . ' implements \\' . $refl->name;
    $t[] = '{';
    $t[] = '    protected $component;';
    $t[] = '    protected $decoratorFactory;';
    $t[] = '';

    $t[] = '    public function __construct(';
    $t[] = '        \\' . $refl->name . ' $component,';
    $t[] = '        \Sulu\Component\PhpcrDecorator\DecoratorFactoryInterface $decoratorFactory';
    $t[] = '    )';
    $t[] = '    {';
    $t[] = '        $this->component = $component;';
    $t[] = '        $this->decoratorFactory = $decoratorFactory;';
    $t[] = '    }';
    $t[] = '';

    $t += $b;

    $t[] = '}';

    $template = implode("\n", $t);

    return $template;
}

function generate_test(\ReflectionClass $refl, $fqcn)
{
    $decoratedFqcn = str_replace('Tests', '', $fqcn);
    $decoratedFqcn = str_replace('Test', '', $fqcn);
    $testName = NS . 'Tests\\' . $fqcn;
    list($className, $namespace) = getClassNamespace($fqcn);
    list($decoratedClassName, $decoratedNamespace) = getClassNamespace($decoratedFqcn);

    $t = array();
    $t[] = '<?php';
    $t[] = '';
    $t[] = 'class ' . $className . ' extends \PHPUnit_Framework_TestCase';
    $t[] = '{';
    $t[] = '    public function setUp()';
    $t[] = '    {';
    $t[] = '        $this->decorated = new ' . NS . $decoratedNamespace . '\\' . $decoratedClassName . ';';
    $t[] = '    }';
    $t[] = '';
    $t[] = '    public function testFoobar()';
    $t[] = '    {';
    $t[] = '    }';
    $t[] = '}';

    return implode("\n", $t);
}
